{
    "problems": [
        {
            "id": "p001",
            "title": "Two Sum",
            "difficulty": "Easy",
            "pattern": "Arrays & Hashing",
            "description": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
            "examples": [
                {
                    "input": "nums = [2,7,11,15], target = 9",
                    "output": "[0,1]"
                },
                {
                    "input": "nums = [3,2,4], target = 6",
                    "output": "[1,2]"
                }
            ],
            "constraints": [
                "2 <= nums.length <= 10^4",
                "-10^9 <= nums[i] <= 10^9"
            ],
            "testCases": [
                {
                    "input": "[2,7,11,15], 9",
                    "expected": [
                        0,
                        1
                    ]
                },
                {
                    "input": "[3,2,4], 6",
                    "expected": [
                        1,
                        2
                    ]
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        pass"
            },
            "hints": [
                "Use a hash map to store the difference and index."
            ]
        },
        {
            "id": "p002",
            "title": "Valid Parentheses",
            "difficulty": "Easy",
            "pattern": "Stack",
            "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
            "examples": [
                {
                    "input": "s = \"()\"",
                    "output": "true"
                },
                {
                    "input": "s = \"()[]{}\"",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= s.length <= 10^4"
            ],
            "testCases": [
                {
                    "input": "\"()\"",
                    "expected": true
                },
                {
                    "input": "\"(]\"",
                    "expected": false
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def isValid(self, s: str) -> bool:\n        pass"
            },
            "hints": [
                "Use a stack to keep track of opening brackets."
            ]
        },
        {
            "id": "p003",
            "title": "Merge Two Sorted Lists",
            "difficulty": "Easy",
            "pattern": "Linked List",
            "description": "Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.",
            "examples": [
                {
                    "input": "l1 = [1,2,4], l2 = [1,3,4]",
                    "output": "[1,1,2,3,4,4]"
                }
            ],
            "constraints": [
                "The number of nodes in both lists is in the range [0, 50]."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        pass"
            },
            "hints": [
                "Create a dummy node and iterate through both lists."
            ]
        },
        {
            "id": "p004",
            "title": "Best Time to Buy and Sell Stock",
            "difficulty": "Easy",
            "pattern": "Sliding Window",
            "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `i-th` day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
            "examples": [
                {
                    "input": "[7,1,5,3,6,4]",
                    "output": "5",
                    "explanation": "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5."
                }
            ],
            "constraints": [
                "1 <= prices.length <= 10^5"
            ],
            "testCases": [
                {
                    "input": "[7,1,5,3,6,4]",
                    "expected": 5
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        pass"
            },
            "hints": [
                "Find the minimum price so far and max profit so far."
            ]
        },
        {
            "id": "p005",
            "title": "Valid Palindrome",
            "difficulty": "Easy",
            "pattern": "Two Pointers",
            "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
            "examples": [
                {
                    "input": "s = \"A man, a plan, a canal: Panama\"",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= s.length <= 2 * 10^5"
            ],
            "testCases": [
                {
                    "input": "\"A man, a plan, a canal: Panama\"",
                    "expected": true
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        pass"
            },
            "hints": [
                "Use two pointers, one from start and one from end."
            ]
        },
        {
            "id": "p006",
            "title": "Invert Binary Tree",
            "difficulty": "Easy",
            "pattern": "Tree",
            "description": "Given the root of a binary tree, invert the tree, and return its root.",
            "examples": [
                {
                    "input": "root = [4,2,7,1,3,6,9]",
                    "output": "[4,7,2,9,6,3,1]"
                }
            ],
            "constraints": [
                "The number of nodes in the tree is in the range [0, 100]."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        pass"
            },
            "hints": [
                "Swap the left and right children recursively."
            ]
        },
        {
            "id": "p007",
            "title": "Valid Anagram",
            "difficulty": "Easy",
            "pattern": "Arrays & Hashing",
            "description": "Given two strings `s` and `t`, return true if `t` is an anagram of `s`, and false otherwise.",
            "examples": [
                {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "output": "true"
                }
            ],
            "constraints": [
                "1 <= s.length, t.length <= 5 * 10^4"
            ],
            "testCases": [
                {
                    "input": "\"anagram\", \"nagaram\"",
                    "expected": true
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        pass"
            },
            "hints": [
                "Check if both strings contain the same count of each character."
            ]
        },
        {
            "id": "p008",
            "title": "Binary Search",
            "difficulty": "Easy",
            "pattern": "Binary Search",
            "description": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return -1.",
            "examples": [
                {
                    "input": "nums = [-1,0,3,5,9,12], target = 9",
                    "output": "4"
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^4"
            ],
            "testCases": [
                {
                    "input": "[-1,0,3,5,9,12], 9",
                    "expected": 4
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        pass"
            },
            "hints": [
                "Use standard binary search logic with left and right bounds."
            ]
        },
        {
            "id": "p009",
            "title": "Flood Fill",
            "difficulty": "Easy",
            "pattern": "Graph",
            "description": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image. You are also given three integers `sr`, `sc`, and `color`. You should perform a flood fill on the image starting from the pixel `image[sr][sc]`.",
            "examples": [
                {
                    "input": "image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2",
                    "output": "[[2,2,2],[2,2,0],[2,0,1]]"
                }
            ],
            "constraints": [
                "m == image.length",
                "n == image[i].length"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Use BFS or DFS to traverse connected pixels of the same color."
            ]
        },
        {
            "id": "p010",
            "title": "Maximum Subarray",
            "difficulty": "Medium",
            "pattern": "Dynamic Programming",
            "description": "Given an integer array `nums`, find the subarray which has the largest sum and return its sum.",
            "examples": [
                {
                    "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6",
                    "explanation": "[4,-1,2,1] has the largest sum = 6."
                }
            ],
            "constraints": [
                "1 <= nums.length <= 10^5"
            ],
            "testCases": [
                {
                    "input": "[-2,1,-3,4,-1,2,1,-5,4]",
                    "expected": 6
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        pass"
            },
            "hints": [
                "Use Kadane's Algorithm to solve this in O(n)."
            ]
        },
        {
            "id": "p011",
            "title": "Lowest Common Ancestor of a BST",
            "difficulty": "Easy",
            "pattern": "Tree",
            "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.",
            "examples": [
                {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                    "output": "6"
                }
            ],
            "constraints": [
                "The number of nodes in the tree is in the range [2, 10^5]."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        pass"
            },
            "hints": [
                "Utilize the BST property: left < root < right to navigate."
            ]
        },
        {
            "id": "p012",
            "title": "Balanced Binary Tree",
            "difficulty": "Easy",
            "pattern": "Tree",
            "description": "Given a binary tree, determine if it is height-balanced.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "true"
                }
            ],
            "constraints": [
                "The number of nodes in the tree is in the range [0, 5000]."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        pass"
            },
            "hints": [
                "A tree is balanced if the height difference between left and right subtrees is at most 1."
            ]
        },
        {
            "id": "p013",
            "title": "Linked List Cycle",
            "difficulty": "Easy",
            "pattern": "Linked List",
            "description": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.",
            "examples": [
                {
                    "input": "head = [3,2,0,-4], pos = 1",
                    "output": "true"
                }
            ],
            "constraints": [
                "The number of the nodes in the list is in the range [0, 10^4]."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        pass"
            },
            "hints": [
                "Use the slow and fast pointer approach (Floyd's Cycle-Finding Algorithm)."
            ]
        },
        {
            "id": "p014",
            "title": "Implement Queue using Stacks",
            "difficulty": "Easy",
            "pattern": "Stack",
            "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (`push`, `peek`, `pop`, and `empty`).",
            "examples": [],
            "constraints": [
                "1 <= x <= 9"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class MyQueue:\n    def __init__(self):\n        pass\n    def push(self, x: int) -> None:\n        pass\n    def pop(self) -> int:\n        pass\n    def peek(self) -> int:\n        pass\n    def empty(self) -> bool:\n        pass"
            },
            "hints": [
                "Use two stacks: one for input and one for output."
            ]
        },
        {
            "id": "p015",
            "title": "First Bad Version",
            "difficulty": "Easy",
            "pattern": "Binary Search",
            "description": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. You are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version.",
            "examples": [],
            "constraints": [
                "1 <= bad <= n <= 2^31 - 1"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        pass"
            },
            "hints": [
                "This is a classic binary search problem."
            ]
        },
        {
            "id": "p016",
            "title": "Ransom Note",
            "difficulty": "Easy",
            "pattern": "Arrays & Hashing",
            "description": "Given two strings `ransomNote` and `magazine`, return true if `ransomNote` can be constructed by using the letters from `magazine` and false otherwise.",
            "examples": [
                {
                    "input": "ransomNote = \"a\", magazine = \"b\"",
                    "output": "false"
                }
            ],
            "constraints": [
                "1 <= ransomNote.length, magazine.length <= 10^5"
            ],
            "testCases": [
                {
                    "input": "\"a\", \"b\"",
                    "expected": false
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        pass"
            },
            "hints": [
                "Count character frequencies in magazine and check if they cover ransomNote."
            ]
        },
        {
            "id": "p017",
            "title": "Climbing Stairs",
            "difficulty": "Easy",
            "pattern": "Dynamic Programming",
            "description": "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
            "examples": [
                {
                    "input": "n = 2",
                    "output": "2"
                }
            ],
            "constraints": [
                "1 <= n <= 45"
            ],
            "testCases": [
                {
                    "input": "2",
                    "expected": 2
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        pass"
            },
            "hints": [
                "This logic is identical to the Fibonacci sequence."
            ]
        },
        {
            "id": "p018",
            "title": "Longest Palindrome",
            "difficulty": "Easy",
            "pattern": "Greedy",
            "description": "Given a string `s` which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.",
            "examples": [
                {
                    "input": "s = \"abccccdd\"",
                    "output": "7"
                }
            ],
            "constraints": [
                "1 <= s.length <= 2000"
            ],
            "testCases": [
                {
                    "input": "\"abccccdd\"",
                    "expected": 7
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def longestPalindrome(self, s: str) -> int:\n        pass"
            },
            "hints": [
                "Pairs of characters can be used fully. One odd character can be placed in the middle."
            ]
        },
        {
            "id": "p019",
            "title": "Reverse Linked List",
            "difficulty": "Easy",
            "pattern": "Linked List",
            "description": "Given the `head` of a singly linked list, reverse the list, and return the reversed list.",
            "examples": [
                {
                    "input": "head = [1,2,3,4,5]",
                    "output": "[5,4,3,2,1]"
                }
            ],
            "constraints": [
                "Nodes in range [0, 5000]."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pass"
            },
            "hints": [
                "Iterate through the list and change the next pointer of each node to point to the previous node."
            ]
        },
        {
            "id": "p020",
            "title": "Majority Element",
            "difficulty": "Easy",
            "pattern": "Arrays & Hashing",
            "description": "Given an array `nums` of size `n`, return the majority element. The majority element is the element that appears more than `n / 2` times.",
            "examples": [
                {
                    "input": "nums = [3,2,3]",
                    "output": "3"
                }
            ],
            "constraints": [
                "n == nums.length",
                "1 <= n <= 5 * 10^4"
            ],
            "testCases": [
                {
                    "input": "[3,2,3]",
                    "expected": 3
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def majorityElement(self, nums: List[int]) -> int:\n        pass"
            },
            "hints": [
                "Use Moore's Voting Algorithm for O(1) space."
            ]
        },
        {
            "id": "p021",
            "title": "Add Binary",
            "difficulty": "Easy",
            "pattern": "Math",
            "description": "Given two binary strings `a` and `b`, return their sum as a binary string.",
            "examples": [
                {
                    "input": "a = \"11\", b = \"1\"",
                    "output": "\"100\""
                }
            ],
            "constraints": [
                "1 <= a.length, b.length <= 10^4"
            ],
            "testCases": [
                {
                    "input": "\"11\", \"1\"",
                    "expected": "100"
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        pass"
            },
            "hints": [
                "Process strings from end to start, managing carry."
            ]
        },
        {
            "id": "p022",
            "title": "Diameter of Binary Tree",
            "difficulty": "Easy",
            "pattern": "Tree",
            "description": "Given the `root` of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them.",
            "examples": [
                {
                    "input": "root = [1,2,3,4,5]",
                    "output": "3",
                    "explanation": "3 is the length of the path [4,2,1,3] or [5,2,1,3]."
                }
            ],
            "constraints": [
                "The number of nodes in the tree is in the range [1, 10^4].",
                "-100 <= Node.val <= 100"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        pass"
            },
            "hints": [
                "For every node, calculate height of left and right subtrees. Diameter through that node is L+R."
            ]
        },
        {
            "id": "p023",
            "title": "Middle of the Linked List",
            "difficulty": "Easy",
            "pattern": "Linked List",
            "description": "Given the `head` of a singly linked list, return the middle node of the linked list.",
            "examples": [
                {
                    "input": "[1,2,3,4,5]",
                    "output": "[3,4,5]"
                }
            ],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        pass"
            },
            "hints": [
                "Use two pointers: fast moves 2 steps, slow moves 1 step."
            ]
        },
        {
            "id": "p024",
            "title": "Maximum Depth of Binary Tree",
            "difficulty": "Easy",
            "pattern": "Tree",
            "description": "Given the `root` of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "3"
                }
            ],
            "constraints": [
                "The number of nodes in the tree is in the range [0, 10^4].",
                "-100 <= Node.val <= 100"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        pass"
            },
            "hints": [
                "Use recursion: depth = 1 + max(left_depth, right_depth)."
            ]
        },
        {
            "id": "p025",
            "title": "Contains Duplicate",
            "difficulty": "Easy",
            "pattern": "Arrays & Hashing",
            "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.",
            "examples": [
                {
                    "input": "nums = [1,2,3,1]",
                    "output": "true"
                }
            ],
            "constraints": [],
            "testCases": [
                {
                    "input": "[1,2,3,1]",
                    "expected": true
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        pass"
            },
            "hints": [
                "Use a hash set to track seen elements."
            ]
        },
        {
            "id": "p026",
            "title": "Insert Interval",
            "difficulty": "Medium",
            "pattern": "Intervals",
            "description": "You are given an array of non-overlapping intervals `intervals` sorted by their start time and an interval `newInterval`. Insert `newInterval` into `intervals` such that `intervals` is still sorted and non-overlapping.",
            "examples": [
                {
                    "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
                    "output": "[[1,5],[6,9]]"
                }
            ],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Handle intervals before, overlapping, and after the new interval separately."
            ]
        },
        {
            "id": "p027",
            "title": "01 Matrix",
            "difficulty": "Medium",
            "pattern": "Graph",
            "description": "Given an `m x n` binary matrix `mat`, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.",
            "examples": [
                {
                    "input": "mat = [[0,0,0],[0,1,0],[0,0,0]]",
                    "output": "[[0,0,0],[0,1,0],[0,0,0]]"
                },
                {
                    "input": "mat = [[0,0,0],[0,1,0],[1,1,1]]",
                    "output": "[[0,0,0],[0,1,0],[1,2,1]]"
                }
            ],
            "constraints": [
                "m == mat.length",
                "n == mat[i].length",
                "1 <= m, n <= 10^4",
                "1 <= m * n <= 10^4",
                "mat[i][j] is either 0 or 1.",
                "There is at least one 0 in mat."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Start BFS from all 0s simultaneously."
            ]
        },
        {
            "id": "p028",
            "title": "K Closest Points to Origin",
            "difficulty": "Medium",
            "pattern": "Heap",
            "description": "Given an array of points where `points[i] = [xi, yi]` and an integer `k`, return the `k` closest points to the origin `(0, 0)`. The distance between two points on the X-Y plane is the Euclidean distance (i.e., `âˆš(x1 - x2)^2 + (y1 - y2)^2`). You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
            "examples": [
                {
                    "input": "points = [[1,3],[-2,2]], k = 1",
                    "output": "[[-2,2]]",
                    "explanation": "The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin."
                },
                {
                    "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
                    "output": "[[3,3],[-2,4]]"
                }
            ],
            "constraints": [
                "1 <= k <= points.length <= 10^4",
                "-10^4 < xi, yi < 10^4"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Use a Max Heap to keep track of the K smallest distances."
            ]
        },
        {
            "id": "p029",
            "title": "Longest Substring Without Repeating Characters",
            "difficulty": "Medium",
            "pattern": "Sliding Window",
            "description": "Given a string `s`, find the length of the longest substring without repeating characters.",
            "examples": [
                {
                    "input": "s = \"abcabcbb\"",
                    "output": "3"
                }
            ],
            "constraints": [],
            "testCases": [
                {
                    "input": "\"abcabcbb\"",
                    "expected": 3
                }
            ],
            "starterCode": {
                "python": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        pass"
            },
            "hints": [
                "Sliding window with a hash map to store indices."
            ]
        },
        {
            "id": "p030",
            "title": "3Sum",
            "difficulty": "Medium",
            "pattern": "Two Pointers",
            "description": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.",
            "examples": [
                {
                    "input": "nums = [-1,0,1,2,-1,-4]",
                    "output": "[[-1,-1,2],[-1,0,1]]"
                }
            ],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Sort the array and use nested loop + two pointers."
            ]
        },
        {
            "id": "p031",
            "title": "Binary Tree Level Order Traversal",
            "difficulty": "Medium",
            "pattern": "Tree",
            "description": "Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
            "examples": [
                {
                    "input": "root = [3,9,20,null,null,15,7]",
                    "output": "[[3],[9,20],[15,7]]"
                }
            ],
            "constraints": [
                "The number of nodes in the tree is in the range [0, 2000].",
                "-1000 <= Node.val <= 1000"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Use BFS with a queue."
            ]
        },
        {
            "id": "p032",
            "title": "Clone Graph",
            "difficulty": "Medium",
            "pattern": "Graph",
            "description": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        pass"
            },
            "hints": [
                "Use DFS/BFS and a hash map to store visited nodes."
            ]
        },
        {
            "id": "p033",
            "title": "Evaluate Reverse Polish Notation",
            "difficulty": "Medium",
            "pattern": "Stack",
            "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.",
            "examples": [
                {
                    "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                    "output": "9"
                }
            ],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        pass"
            },
            "hints": [
                "Use a stack to process operands and operators."
            ]
        },
        {
            "id": "p034",
            "title": "Course Schedule",
            "difficulty": "Medium",
            "pattern": "Graph",
            "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
            "examples": [
                {
                    "input": "numCourses = 2, prerequisites = [[1,0]]",
                    "output": "true",
                    "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
                },
                {
                    "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                    "output": "false",
                    "explanation": "To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
                }
            ],
            "constraints": [
                "1 <= numCourses <= 2000",
                "0 <= prerequisites.length <= 5000",
                "prerequisites[i].length == 2",
                "All the pairs prerequisites[i] are unique."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        pass"
            },
            "hints": [
                "Detect cycle in a directed graph using DFS or Topological Sort."
            ]
        },
        {
            "id": "p035",
            "title": "Implement Trie (Prefix Tree)",
            "difficulty": "Medium",
            "pattern": "Trie",
            "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Trie:\n    def __init__(self):\n        pass\n    def insert(self, word: str) -> None:\n        pass\n    def search(self, word: str) -> bool:\n        pass\n    def startsWith(self, prefix: str) -> bool:\n        pass"
            },
            "hints": [
                "Each node should contain a map/array of its children."
            ]
        },
        {
            "id": "p036",
            "title": "Coin Change",
            "difficulty": "Medium",
            "pattern": "Dynamic Programming",
            "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money. Return the fewest number of coins needed to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.",
            "examples": [
                {
                    "input": "coins = [1,2,5], amount = 11",
                    "output": "3",
                    "explanation": "11 = 5 + 5 + 1"
                },
                {
                    "input": "coins = [2], amount = 3",
                    "output": "-1"
                },
                {
                    "input": "coins = [1], amount = 0",
                    "output": "0"
                }
            ],
            "constraints": [
                "1 <= coins.length <= 12",
                "1 <= coins[i] <= 2^31 - 1",
                "0 <= amount <= 10^4"
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        pass"
            },
            "hints": [
                "DP bottom-up: dp[i] = min(dp[i], dp[i-coin] + 1)."
            ]
        },
        {
            "id": "p037",
            "title": "Product of Array Except Self",
            "difficulty": "Medium",
            "pattern": "Arrays & Hashing",
            "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.",
            "examples": [
                {
                    "input": "nums = [1,2,3,4]",
                    "output": "[24,12,8,6]"
                }
            ],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        pass"
            },
            "hints": [
                "Use prefix and suffix product arrays."
            ]
        },
        {
            "id": "p038",
            "title": "Valid Binary Search Tree",
            "difficulty": "Medium",
            "pattern": "Tree",
            "description": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        pass"
            },
            "hints": [
                "Keep track of valid min and max ranges for each node."
            ]
        },
        {
            "id": "p039",
            "title": "Number of Islands",
            "difficulty": "Medium",
            "pattern": "Graph",
            "description": "Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
            "examples": [
                {
                    "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                    "output": "1"
                },
                {
                    "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                    "output": "3"
                }
            ],
            "constraints": [
                "m == grid.length",
                "n == grid[i].length",
                "1 <= m, n <= 300",
                "grid[i][j] is '0' or '1'."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        pass"
            },
            "hints": [
                "Loop through grid, start DFS/BFS when '1' is found to mark visited."
            ]
        },
        {
            "id": "p040",
            "title": "Rotting Oranges",
            "difficulty": "Medium",
            "pattern": "Graph",
            "description": "You are given an `m x n` grid where each cell can have one of three values:\n- `0` representing an empty cell,\n- `1` representing a fresh orange, or\n- `2` representing a rotten orange.\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return `-1`.",
            "examples": [
                {
                    "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
                    "output": "4"
                },
                {
                    "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
                    "output": "-1",
                    "explanation": "The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally."
                },
                {
                    "input": "grid = [[0,2]]",
                    "output": "0",
                    "explanation": "Since there are no fresh oranges at minute 0, the answer is just 0."
                }
            ],
            "constraints": [
                "m == grid.length",
                "n == grid[i].length",
                "1 <= m, n <= 10",
                "grid[i][j] is 0, 1, or 2."
            ],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        pass"
            },
            "hints": [
                "Multi-source BFS starting from all rotten oranges."
            ]
        },
        {
            "id": "p041",
            "title": "Search in Rotated Sorted Array",
            "difficulty": "Medium",
            "pattern": "Binary Search",
            "description": "Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        pass"
            },
            "hints": [
                "Determine which half is sorted, then check if target is in that range."
            ]
        },
        {
            "id": "p042",
            "title": "Combination Sum",
            "difficulty": "Medium",
            "pattern": "Backtracking",
            "description": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of `candidates` where the chosen numbers sum to `target`.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Use backtracking. Sort candidates for optimization."
            ]
        },
        {
            "id": "p043",
            "title": "Permutations",
            "difficulty": "Medium",
            "pattern": "Backtracking",
            "description": "Given an array `nums` of distinct integers, return all the possible permutations.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Backtracking with a visited set or swapping."
            ]
        },
        {
            "id": "p044",
            "title": "Merge Intervals",
            "difficulty": "Medium",
            "pattern": "Intervals",
            "description": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        pass"
            },
            "hints": [
                "Sort by start time first."
            ]
        },
        {
            "id": "p045",
            "title": "Lowest Common Ancestor of a Binary Tree",
            "difficulty": "Medium",
            "pattern": "Tree",
            "description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        pass"
            },
            "hints": [
                "Recursively check left and right subtrees."
            ]
        },
        {
            "id": "p046",
            "title": "Time Based Key-Value Store",
            "difficulty": "Medium",
            "pattern": "Binary Search",
            "description": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class TimeMap:\n    def __init__(self):\n        pass\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        pass\n    def get(self, key: str, timestamp: int) -> str:\n        pass"
            },
            "hints": [
                "Store values as list of [time, value] pairs. Use binary search."
            ]
        },
        {
            "id": "p047",
            "title": "Accounts Merge",
            "difficulty": "Medium",
            "pattern": "Graph",
            "description": "Given a list of `accounts` where each element is a list of strings, the first element is a name, and the rest are emails. Merge accounts.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        pass"
            },
            "hints": [
                "Union-Find or DFS to connect components."
            ]
        },
        {
            "id": "p048",
            "title": "Sort Colors",
            "difficulty": "Medium",
            "pattern": "Two Pointers",
            "description": "Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        pass"
            },
            "hints": [
                "Dutch National Flag problem (3-way partition)."
            ]
        },
        {
            "id": "p049",
            "title": "Word Break",
            "difficulty": "Medium",
            "pattern": "Dynamic Programming",
            "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.",
            "examples": [],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        pass"
            },
            "hints": [
                "dp[i] = any(dp[j] and s[j:i] in dict)."
            ]
        },
        {
            "id": "p050",
            "title": "Spiral Matrix",
            "difficulty": "Medium",
            "pattern": "Arrays & Hashing",
            "description": "Given an `m x n` matrix, return all elements of the matrix in spiral order.",
            "examples": [
                {
                    "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[1,2,3,6,9,8,7,4,5]"
                }
            ],
            "constraints": [],
            "testCases": [],
            "starterCode": {
                "python": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        pass"
            },
            "hints": [
                "Simulate the process with 4 boundaries."
            ]
        }
    ]
}